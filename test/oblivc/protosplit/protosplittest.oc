#include <obliv.oh>
#include <obliv_common.h>
#include "protosplittest.h"

void reducelist(obliv uint32_t * output, uint32_t * input, size_t len, size_t index, ProtocolDesc * pds) {
	ocSetCurrentProto(&pds[index]);

	for (size_t ii = 0; ii < len; ii ++) {
		obliv uint32_t in = feedOblivInt(input[index*len+ii], ii%2 + 1);
		output[index] += in;
	}

	// we want to flush if our protocol is done and other threads are waiting on us
	// in this case, it's not strictly necessary, but it's a good habit.
	oflush(&pds[index]);
}

void goprotosplit(void* vargs) {
	struct args * a = vargs;
	fprintf(stdout, "Threads: %d, Elements (each): %u, Total: %u\n", a->threads, a->elct, a->threads * a->elct);

	obliv uint32_t * output = calloc(a->threads, sizeof(obliv uint32_t));

	uint32_t * input = malloc(a->threads * a->elct * sizeof(uint32_t));
	for (size_t ii = 0; ii < a->threads * a->elct; ii++) input[ii] = ii+1;

	ProtocolDesc * pdorig = ocCurrentProto();	
	ProtocolDesc * pds = malloc(a->threads * sizeof(ProtocolDesc));
	for (size_t ii = 0; ii < a->threads; ii++) ocSplitProto(&pds[ii], ocCurrentProto());
	parallelize(reducelist, output, input, a->elct, a->threads, pds);
	for (size_t ii = 0; ii < a->threads; ii++) ocCleanupProto(&pds[ii]);
	ocSetCurrentProto(pdorig);

	for (size_t ii = 1; ii < a->threads; ii++)  {
		output[0] += output[ii];
	}
	
	uint32_t result;
	revealOblivInt(&result, output[0], 0);
	fprintf(stdout, "Result: %u, Expected: %u\n", result, (a->elct*a->threads+1)*(a->elct*a->threads)/2);
	free(input);
	free(output);
	free(pds);
}